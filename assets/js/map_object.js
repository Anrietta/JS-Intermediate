                // Об'єкт MAP (MAP object)

        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects - вбудовані обєкти
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map - об'єкт MAP


// Map – це колекція ключ/значення, як і Object. Але основна відмінність полягає в тому, що Map дозволяє мати ключі будь-якого типу, тоді як Об'єкт дозволяє мати ключі лише типу String та Symbol

// Методи та властивості MAP :

// new Map() – створює колекцію.
// map.set(key, value) – зберігає значення value за ключем key.
// map.get(key) – повертає значення за ключем; повертає undefined якщо key немає в колекції.
// map.has(key) – повертає true якщо key існує, інакше false.
// map.delete(key) – видаляє елемент (пару ключ/значення) за ключем.
// map.clear() – видаляє всі елементи колекції.
// map.size – повертає поточну кількість елементів.


// MAP створюється лише за допомогою конструктора

// const map1 = new Map();
// console.log('map1 :>> ', map1);  // Map(0) {size: 0}

// // властивість size у map це таке саме як у array властивість length
// console.log('map1.size :>> ', map1.size);  // 0


// // 1. метод set() - задати значення з map


// // коли ми задавали обєктам якіість властивості чи їм значення ми писали так obj.key = value
// // щоб задати в MAP значення якомусь ключу  використовуємо метод set
// map1.set(1, 2);  // Map(1) {1 => 2}
// map1.set('firstName', 'Test') // Map(2) {1 => 2, 'firstName' => 'Test'}
// map1.set('firstName', 'Test1') // Map(2) {1 => 2, 'firstName' => 'Test1'} - якщо двічі задавати значення з тим самим ключем то значення перезапишеться! назви ключів мають відрізнятись


// // за допомогою методу set можна створювати ланцюжок set, оскільки set повертає змінений map, ось так:
// map1.set('firstName', 'Test2').set('lastName', 'Testovych2').set('age', 25)
// console.log('map1 :>> ', map1);  // Map(4) {1 => 2, 'firstName' => 'Test2', 'lastName' => 'Testovych2', 'age' => 25}


// // задаємо map обєкт в якості ключа і масив в якості значення
// map1.set({id:1, name: 'Ivo'}, ['hello', 'I"m fine'])  // 2:{Object => Array(2)} key: {id: 1, name: 'Ivo'} value: (2) ['hello', 'I"m fine']


// // 2. метод get() - отримати значення з map

// // коли ми хотіли отримати з обєкта якіість властивості чи їх значення ми писали так obj.key
// // щоб задати в MAP значення якомусь ключу  використовуємо метод get

// console.log(map1.get('firstName'));  // Test2
// console.log(map1.get({id:1, name: 'Ivo'}));  // undefined - тому що обєкт зберігає в собі посилання а не самі значення, щоб get-ом дістатись до ключа-обєкта треба спершу зберегти цей обєкт в змінну і як ключ вказувати саме назву змінної

// const user = {id:1, name: 'Ivo2'};  //  створити зінну, значення якої обєкт, який буде ключем в map
// map1.set(user, ['hello', 'I feel bad']);  // задаємо map ключ та значення (в якості ключа посилання на змінну де зберігається обєкт)
// console.log(map1.get(user));  // ['hello', 'I feel bad']  - отримуємо значення за допомогою посилання на змінну в якій міститься обжкт який є ключем в map


// // 3. метод has() - перевірити чи існує ключ в map (true, false)

// // коли ми перевіряли у обєктів чи є ключ в середині ми писали obj in key
// // для map також є метод has щоб це перевірити
// console.log(map1.has('lastName'));  // true
// console.log(map1.has('phone'));  // false

//         // Наприклад маємо такий map (телефонна книжка):

//         const map2 = new Map();

//         map2.set('Test', '+380123456789')
//             .set('Test2', '+380123456788')
//             .set('Test3', '+380123456787');

//         // перервірити чи є номер абонента Test та Ivo
//         console.log(map2.has('Test'));  // true
//         console.log(map2.has('Ivo'));  // false



// // 4. метод delete() - видалити пару ключ/значення з map (повертає булеве значення)

// // коли ми для обєктів видаляли властивість/ключ ми писали delete obj.key
// // для map теж існує метод delete()

// map2.delete('Test')
// console.log(map2);  // Map(2) {'Test2' => '+380123456788', 'Test3' => '+380123456787'}



// // 5. метод clear() - очистити map (видалити всі дані, всі пари ключ/значення)

// // map2.clear();
// console.log(map2);  // Map(0) {size: 0} - пусто, все видалили, всі пари ключ/значення



// // Для перебору колекції Map є 3 метода:

// // forEach()
// // map.keys() – повертає об’єкт-ітератор mapIterator для ключів,
// // map.values() – повертає об’єкт-ітератор mapIterator для значень,
// // map.entries() – повертає об’єкт-ітератор mapIterator зі значеннями виду [ключ, значення], цей варіант типово використовується з for..of.

// // Об’єкт-ітератор mapIterator - має властивість Symbol.iterator, тобто він ітерабельний, 
// // тобто за допомогою for...of, деструктуризації та spread оператора можна змінити його тип на Array і вже до нього застосовувати всі методи масивів



// // 1. метод forEach() - щою перебрати кожен елемент map і щось з ним зробити
// // переберемо map за допомогою forEach()
// map2.forEach((value, key) => console.log(key, value));  // Test2 +380123456788   Test3 +380123456787


// // 2. метод keys() - щоб отримати ключі з map, повертає об`єкт MapIterator, який має властивість Symbol.iterator в ланцюжку прототипів і тому може ітеруватись/ перебиратись

// console.log(map2.keys());  // MapIterator {'Test2', 'Test3'}
// const mapKeys = [...map2.keys()];  // за допомогою spread оператора ключі mapIterator розгортаємо та зберігаємо в масив а далі можем до них застосовувати будь які методи масивів
// console.log(mapKeys); //(2) ['Test2', 'Test3'] - array


// // 3. метод values() - щоб отримати значення з map, повертає ообєкт MapIterator, який має властивість Symbol.iterator в ланцюжку прототипів і тому може ітеруватись/ перебиратись
// console.log(map2.values());  // MapIterator {'+380123456788', '+380123456787'}
// console.log([...map2.values()]);  // (2) ['+380123456788', '+380123456787']  - array - тут ми зразу map розгортаємо в масив і витягуємо його значення (можна так само як в методі keys)


// // 4. метод entries() - щоб отримати пари ключ/значення з map, повертає ообєкт MapIterator, який має властивість Symbol.iterator в ланцюжку прототипів і тому може ітеруватись/ перебиратись

// console.log(map2.entries());   // MapIterator {'Test2' => '+380123456788', 'Test3' => '+380123456787'}
// console.log([...map2.entries()]);  // (2) [Array(2), Array(2)] 0: (2) ['Test2', '+380123456788'] 1: (2) ['Test3', '+380123456787']   - array - тут ми зразу map розгортаємо в масив і витягуємо його пари ключ/значення (можна так само як в методі keys зберегти в змінну)




// // **********

// // створюємо map з обєкта за допомогою Object.entries(obj) - отримуємо масив масивів (ключ/значення), який спокійно можем перетворити в map
// // map дозволяє створювати себе за допомогою масиву, що містить масиви, які містять по два значення ключ/значення [['Test', 23], ['Test1', 74]]

// const obj = {
//     Test: '23',
//     Test1: '74'
// }

// console.log(Object.entries(obj));  // [['Test', 23], ['Test1', 74]] - отримуємо масив масивів

// const map3 = new Map(Object.entries(obj));  // Map(2) {'Test' => '23', 'Test1' => '74'} - отриманий масив масивів з обєкта зразу зберігаємо в map при його створенні 



// ---------------------------------------------------------------------------------------------------------------

// існує дуже схожий на map вид колекції який називається FormData - який використовується при відправці даних на сервер
// ми про нього повчимо пізніше

// https://developer.mozilla.org/en-US/docs/Web/API/FormData


// --------------------------------------------------------------------------------------------------------------------



// Задачка: перекладач. Словник міститься в map

// const vocabulary = new Map();  // створюємо словничок в map
// vocabulary.set('dog', 'собака').set('cat', 'кіт').set('run', 'бігати');  // наповнюємо словничок парами (ключ(анг)/значення(укр))
// console.log(vocabulary);  // Map(3) {'dog' => 'собака', 'cat' => 'кіт', 'run' => 'бігати'}


// 1 варіант функції покроково, щоб було зрозуміло
// function translateEngToUa(engPhrase) {
//     // map працює з окремими словами,а  у нас фраза
//     // треба отримати масив англ слів ['dog', 'run', 'white', 'cat']
//     const engWords = engPhrase.split(' ')
//     console.log(engWords);  // (4) ['dog', 'run', 'white', 'cat']

//     // за допомогою словника пробігтись по масиву і якщо є відповідний ключ отримати для ключів значення (отримаємо такий масив ['собака', 'бігти', 'white', 'кіт'])
//     // якщо нема відповідного ключа - залиши слово без змін
//     const uaWords = engWords.map(w => vocabulary.has(w) ? vocabulary.get(w) : w);
//     console.log(uaWords);  // (4) ['собака', 'бігати', 'white', 'кіт']

//     // з отриманого масиву переробити слова у фразу (string)

//     const uaPhrase = uaWords.join(' ');  // 'собака бігати white кіт'
//     console.log(uaPhrase);

//     return uaPhrase;
// }


// 2 варіант функції - скорочений
// function translateEngToUa(engPhrase) {

//     return engPhrase
//         .split(' ')
//         .map(w => vocabulary.has(w) ? vocabulary.get(w) : w)
//         .join(' ');

//     // де : engPhrase.split(' ') - отриману фразу розділяємо за пробілом на слова і поміщаємо в масив
//         // map(w => vocabulary.has(w) ? vocabulary.get(w) - проходимся по отриманому масиву та по словнику в мапі шукаючи співпадіння за кожним словом, якщо є співпадіння повертаєм в той самий масив значення ключа з мапи, якщо нема співпадіння залишаєм слово без змін
//         // .join(' ') - масив з значеннями ключів з мапи перетворюємо в стрінг з роздільником пробіл
//         //  і повертаємо назад перекладену фразу (стрінг)
// }

// 3 варіант функції - arrow function
// const translateEngToUa = engPhrase => engPhrase
//     .split(' ')
//     .map(w => vocabulary.has(w) ? vocabulary.get(w) : w)
//     .join(' ');



// const engPhrase = 'run dog white cat tomorrow';  // фраза яку ми отримали від користувача і передаємо як аргумент у функцію
// const ukrPhrase = translateEngToUa(engPhrase);  // ми хочемо отримати таке "собака бігати white кіт"
// console.log(ukrPhrase);