                // Деструктуруюче присвоєння

// https://uk.javascript.info/destructuring-assignment

// Деструктуроване присвоєння - це спеціальний синтаксис, що дозволяє "розпакувати" масиви Array чи об'єкти Object в купу змінних




            // Деструктуризація Обєктів (Objects destructurisation)



// function f(user) {

//     console.log(user);
//     //щоб отримати дані поокремо ми звикли звертатись до властивості через крапку, так не прийнято робити, бо при великих даних чи вкладеннях доведеться писати довжелезні ланцюжки шляхів.
//     // console.log(user.firstName);
//     // console.log(user.lastName);
//     // тобто щоб отримати ці значення нам доведеться створювати змінні куди присвоювати ці значення:
//     // const firstName = user.firstName;
//     // const lastName = user.lastName;
//     // console.log(firstName);
//     // console.log(lastName);

//     // щоб не писати довжелезні ланцюжки шляхів до даних і зайві змінні використовуємо синтаксис деструктуруючого присвоєння
//     // імена параметрів в змінній мають називатись так само як назва властивості в обєкті який ми деструктуруємо
//     // саме такий синтаксис використовується в роботі, використання через крапку є дурним тоном

//     // const {firstName, lastName, age} = user;
//     // console.log(firstName);
//     // console.log(lastName);

// }

// можна зробити ще простіше {firstName, lastName, age} вписати прямо в параметрах фунцкії (там автоматично створюється тимчасова змінна, і передаючи при виклику функції обєкт ми одразу проведем деструктуризацію)
// головна умова щоб назви співпадали з назвами властивостей в обєкті який ми передаємо у функцію

// function f({firstName, lastName, age}) {
//     console.log(user);
//     console.log(firstName);
//     console.log(lastName);
// }

// const user = {
//     firstName: 'Test',
//     lastName: 'Testovich',
//     age: 25
// }

// f(user);


// Задачка:
// оголосити змінні використовуючи деструктуроване присвоєння

// const book = {
//     author: 'Ted Magley',
//     title: 'Ooops'
// };

// варіант 1 без використ функції
// const {author, title} = book;
// console.log(book);


// варіант 2 з використанням функції
// function books({author, title}) {
//     console.log(title);
//     console.log(author);
// }

// books(book);


// ------------------------------------------------------------------------------------------------------------------

// Приклад деструктуризації обєкту з вкладеними властивостями

// const book = {
//     author: {
//         firstName: 'Ted',
//         lastName: 'Magley'
//     },
//     title: 'Ooops',
//     price: 12
// };

// якщо ми запишемо отак як нижче, то замість примітивних даних з author отримаємо обєкт, і у нас виникнуть проблеми
// const {author, price} = book;
// console.log(price); // тут отримаємо дані з властивості
// console.log(author); // отримаємо обєкт а не дані з нього

// правильно писати отак author:{firstName, lastName} (де ми author розпаковуємо і перейменовуємо на firstName, lastName, перейменування відбувається за рахунок символу":"), деструктурувати author прямо на місці, і назвами змінних цих будуть назви властивостей обєкта
// const {author:{firstName, lastName}, price} = book;
// console.log(price); // тут отримаємо дані з властивості 12
// console.log(firstName); // отримаємо дані Ted
// console.log(lastName); // отримаємо дані Magley
// console.log(author); //  - в такому випадку змінної author не існує, тобто замість неї ми звертаємось до firstName та lastName



// ---------------------------------------------------------------------------------------------------------------------------------

// ":" як синтаксис переіменування 

// const {author:{firstName, lastName},
//         price: bookPrice  // синтаксис переіменування з price на bookPrice
// } = book;
// console.log(bookPrice);  // 12 
// console.log(price);  // тепер price не існує!


// -------------------------------------------------------------------------------------------------------------------------------

// Що робити якщо один з параметрів не прийде в функцію при деструктуризації?
// те саме що і зі звичайними параметрами функцій - задати значення по замовчуванню 
// різнця в тому що при деструктуризації саме порядок цих параметрів не важливий бо вони є властивостяи обєкту, тут його можна застосовувати в будь якому порядку
// а у функціях обовязковою умовою є щоб значення по замовчуванню йшло останнім в кінці списку параметрів

// function f({firstName, lastName, age = 0}) {  // тут для параметра age задаємо значення за замовчуванням 0, на випадок якщо не прийде параметр
//     console.log(user);
//     console.log(firstName);
//     console.log(lastName);
//     console.log(age);  // undefined якщо ми не задали значення за замовчуванням, або саме значення за замовч якщо ми його задали в параметрах
// }

// const user = {
//     firstName: 'Test',
//     lastName: 'Testovich',
//     // наприклад немає в нас параметра age а ми в параметрах функції його очікуємо
// }

// f(user);




// -----------------------------------------------------------------------------------------------------------------------------


                // Деструктуризація масивів (Arrays Destructurisation)


// При деструктурованому присвоєнні в обєктах ми вигравали за рахунок того що властивості обєктів мають імена і нові змінні повинні були мати такі ж назви змінних як і назва властивості в обєкті, які відсутні в масивах
// Тобто в масиві ми будем вибирати їх за порядком (індексом)

// const arr = [1, 2, 3, 4];

// можна звертатись до кожного індекса і присвоювати його в створену змінну, але це тупо, довго і не зручно
// const arr0 = arr[0];
// const arr1 = arr[1];

// а можна деструктуруввати масив отак:
// називати їх можна хоть як, але значення він братиме по порядку як вони розташовані в масиві

        //1    2    3     4
// const [arr0, arr1, arr15, arr123] = arr;
// console.log(arr1); //2
// console.log(arr123); //4


// А як отримати 1, 2 і 4  якщо наприклад 3 мені непотрібне і я нехочу його отримати при деструктуризації, адже значення отримуються саме по порядку розташування
// відділимо його комами не задаючи назви, так ми просто порпустимо один символ між 2 і 4, і неважливо що там було

                 //1    2       4
        // const [arr0, arr1, , arr123] = arr;
        // console.log(arr0); // 1
        // console.log(arr1); // 2
        // console.log(arr123); // 4




// =================================================================================================================================

//Змішана задачка з масивом в обєкті
//перейменувати name -> userName, age -> userAge
// name, age, email1, email2, isMail

const user1 = {
    name: 'Test',
    age: 23,
    emails: ['test1@test.com', 'test2@test.com'],
    isMale: true
};

// const {
//     name:userName,              // перейменовуємо name на userName
//     age:userAge,                // перейменовуємо age на userAge
//     emails:[email1, email2],   // розпаковуємо масив emails і перейменовуємо на email1, email2
//     isMale
// } = user1;

// console.log(userName, userAge, email1, email2, isMale); // все працює


const {emails:[email1, email2], ...restParams} = user1;
console.log(email1, email2);  // test1@test.com test2@test.com
console.log(restParams);  // {name: 'Test', age: 23, isMale: true}




// -----------------------------------------------------------------------------------------------------------------------

// Таск щоб отримати лише певні дані з обєкту

// Уявімо що ми отримуємо з сервера обєкт атрибутів для взаємодії HTML з JS
// але нам не потрібні всі ці атрибути для роботи зараз, лише деякі потрібні а аінші можна відкласти окремо

const attr = {id: 'btn', style: 'color:blue', title: 'click me'};

// отже, нам потрібно дістати окремо атрибут style і окремо решту властивостей запакувати в окремий обєкт (бо ми їх не будемо використовувати)
// style, {id, title}

// можна використати рест параметри (залишкові параметри які пакуються в обєкт) деструктуризацію як в попередніх прикладах
    // у функціях рест параметри пакуються в масив, а при деструктуризації - пакуються в обєкт
    // але рест параметр має бути останнім серед параметрів завжди!

const {style, ...restAttr} = attr;
console.log(style); // color:blue
console.log(restAttr);  // {id: 'btn', title: 'click me'}


// Отже Деструктуризація не знищує обєкт, а лише спосіб розібрати на частини обєкт і присвоїти їх значення новим змінним
// деструктуризація - це особливий вигляд присвоювання
// він діє для оєктів і масивів
// Основною вимогою при деструктуризації обєктктів є те, що імена змінних та імена властивостей обєкту мають бути однаковими
// Основною вимогою деструктуризації масивів є те, що має зберігатись порядок індексів. Якщо якийсь один елемент хочемо пропустти то лишаємо замість нього пробіл
// можна використовувати перейменування старе імя : нове імя
// можна використовувати складні вкладення обєкти в обєктах. масиви в оєктах і т.д. просто кожеш шар вкладення треба деструктуризувати
// якщо виконуємо деструктуризацію обєкту за допомогою функції то не забуваємоо коритсуватись значенням параметра за замовчуванням на випадок якщо не отримаємо параметр
// використовувати рест параметр при деструктуризації якзо нам потрібно відщипнути окремо шматок обєкта а інше спакувати в окрему змінну 

