                // Деструктуруюче присвоєння

// https://uk.javascript.info/destructuring-assignment

// Деструктуроване присвоєння - це спеціальний синтаксис, що дозволяє "розпакувати" масиви Array чи об'єкти Object в купу змінних




            // Деструктуризація Обєктів (Objects destructurisation)



// function f(user) {

//     console.log(user);
//     //щоб отримати дані поокремо ми звикли звертатись до властивості через крапку, так не прийнято робити, бо при великих даних чи вкладеннях доведеться писати довжелезні ланцюжки шляхів.
//     // console.log(user.firstName);
//     // console.log(user.lastName);
//     // тобто щоб отримати ці значення нам доведеться створювати змінні куди присвоювати ці значення:
//     // const firstName = user.firstName;
//     // const lastName = user.lastName;
//     // console.log(firstName);
//     // console.log(lastName);

//     // щоб не писати довжелезні ланцюжки шляхів до даних і зайві змінні використовуємо синтаксис деструктуруючого присвоєння
//     // імена параметрів в змінній мають називатись так само як назва властивості в обєкті який ми деструктуруємо
//     // саме такий синтаксис використовується в роботі, використання через крапку є дурним тоном

//     // const {firstName, lastName, age} = user;
//     // console.log(firstName);
//     // console.log(lastName);

// }

// можна зробити ще простіше {firstName, lastName, age} вписати прямо в параметрах фунцкії (там автоматично створюється тимчасова змінна, і передаючи при виклику функції обєкт ми одразу проведем деструктуризацію)
// головна умова щоб назви співпадали з назвами властивостей в обєкті який ми передаємо у функцію

// function f({firstName, lastName, age}) {
//     console.log(user);
//     console.log(firstName);
//     console.log(lastName);
// }

// const user = {
//     firstName: 'Test',
//     lastName: 'Testovich',
//     age: 25
// }

// f(user);


// Задачка:
// оголосити змінні використовуючи деструктуроване присвоєння

// const book = {
//     author: 'Ted Magley',
//     title: 'Ooops'
// };

// варіант 1 без використ функції
// const {author, title} = book;
// console.log(book);


// варіант 2 з використанням функції
// function books({author, title}) {
//     console.log(title);
//     console.log(author);
// }

// books(book);


// ------------------------------------------------------------------------------------------------------------------

// Приклад деструктуризації обєкту з вкладеними властивостями

// const book = {
//     author: {
//         firstName: 'Ted',
//         lastName: 'Magley'
//     },
//     title: 'Ooops',
//     price: 12
// };

// якщо ми запишемо отак як нижче, то замість примітивних даних з author отримаємо обєкт, і у нас виникнуть проблеми
// const {author, price} = book;
// console.log(price); // тут отримаємо дані з властивості
// console.log(author); // отримаємо обєкт а не дані з нього

// правильно писати отак author:{firstName, lastName} (де ми author розпаковуємо і перейменовуємо на firstName, lastName, перейменування відбувається за рахунок символу":"), деструктурувати author прямо на місці, і назвами змінних цих будуть назви властивостей обєкта
// const {author:{firstName, lastName}, price} = book;
// console.log(price); // тут отримаємо дані з властивості 12
// console.log(firstName); // отримаємо дані Ted
// console.log(lastName); // отримаємо дані Magley
// console.log(author); //  - в такому випадку змінної author не існує, тобто замість неї ми звертаємось до firstName та lastName



// ---------------------------------------------------------------------------------------------------------------------------------

// ":" як синтаксис переіменування 

// const {author:{firstName, lastName},
//         price: bookPrice  // синтаксис переіменування з price на bookPrice
// } = book;
// console.log(bookPrice);  // 12 
// console.log(price);  // тепер price не існує!


// -------------------------------------------------------------------------------------------------------------------------------

// Що робити якщо один з параметрів не прийде в функцію при деструктуризації?
// те саме що і зі звичайними параметрами функцій - задати значення по замовчуванню 
// різнця в тому що при деструктуризації саме порядок цих параметрів не важливий бо вони є властивостяи обєкту, тут його можна застосовувати в будь якому порядку
// а у функціях обовязковою умовою є щоб значення по замовчуванню йшло останнім в кінці списку параметрів

// function f({firstName, lastName, age = 0}) {  // тут для параметра age задаємо значення за замовчуванням 0, на випадок якщо не прийде параметр
//     console.log(user);
//     console.log(firstName);
//     console.log(lastName);
//     console.log(age);  // undefined якщо ми не задали значення за замовчуванням, або саме значення за замовч якщо ми його задали в параметрах
// }

// const user = {
//     firstName: 'Test',
//     lastName: 'Testovich',
//     // наприклад немає в нас параметра age а ми в параметрах функції його очікуємо
// }

// f(user);




// -----------------------------------------------------------------------------------------------------------------------------


                // Деструктуризація масивів (Arrays Destructurisation)


// При деструктурованому присвоєнні в обєктах ми вигравали за рахунок того що властивості обєктів мають імена і нові змінні повинні були мати такі ж назви змінних як і назва властивості в обєкті, які відсутні в масивах
// Тобто в масиві ми будем вибирати їх за порядком (індексом)

// const arr = [1, 2, 3, 4];

// можна звертатись до кожного індекса і присвоювати його в створену змінну, але це тупо, довго і не зручно
// const arr0 = arr[0];
// const arr1 = arr[1];

// а можна деструктуруввати масив отак:
// називати їх можна хоть як, але значення він братиме по порядку як вони розташовані в масиві

        //1    2    3     4
// const [arr0, arr1, arr15, arr123] = arr;
// console.log(arr1); //2
// console.log(arr123); //4


// А як отримати 1, 2 і 4  якщо наприклад 3 мені непотрібне і я нехочу його отримати при деструктуризації, адже значення отримуються саме по порядку розташування
// відділимо його комами не задаючи назви, так ми просто порпустимо один символ між 2 і 4, і неважливо що там було

                 //1    2       4
        // const [arr0, arr1, , arr123] = arr;
        // console.log(arr0); // 1
        // console.log(arr1); // 2
        // console.log(arr123); // 4