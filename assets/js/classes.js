                // Classes (Класи)c


                // https://uk.javascript.info/class
                // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes

//  JS Прототипна мова програмування- це стиль програмування при якому відсутнє поняття класу, а повторне використоання (успадкування) проводиться шляхом клонування наявного примірника ОБ'ЄКТА - прототипу.

// JS Об'єктно-орієнтоване програмування - одна з прадигм програмування, яка розглядає програму як мнодину об'єктів, що взаємодіють між собою. 
// Основу ООП складають чотири основні концепції (принципи) : інкапсуляція, успадкування, поліморфізм та абстракція.

// В інших високорівневих об'єктно-орієнтованих мовах програмування (С++, Java, C#...) все що у JS реалізується прототипами, те в інших реалізується Класами

// В JS пізніше також ввели поняття Класів.


// Повернемось до функцій-конструкторів для розуміння: розгорни згорнутий комент нижче


/*
Прототипи об'єктів в JS при використанні функцій-конструкторів
У JavaScript, кожен об'єкт має властивість [[Prototype]] (яка історично була доступна через __proto__, а зараз рекомендований спосіб доступу - Object.getPrototypeOf()). Ця властивість вказує на інший об'єкт, який є його "прототипом". Коли ви намагаєтеся отримати доступ до властивості або методу об'єкта, а його немає безпосередньо на цьому об'єкті, JavaScript шукає його в ланцюжку прототипів.

Функції-конструктори та прототипи
Функції-конструктори – це звичайні функції, які викликаються за допомогою ключового слова new. Їхнє основне призначення – створювати нові об'єкти.

Коли ви створюєте функцію-конструктор, вона автоматично отримує властивість prototype. Ця властивість prototype (зверніть увагу, що це властивість самої функції, а не екземпляра об'єкта) є звичайним об'єктом.

Ось як це працює крок за кроком:

Створення функції-конструктора:


    function Car(make, model) {
      this.make = make;
      this.model = model;
    }
Властивість prototype конструктора:
Кожен функція-конструктор Car має властивість Car.prototype. За замовчуванням, Car.prototype — це просто порожній об'єкт, який має лише одну властивість constructor, що посилається назад на саму функцію Car.


    console.log(Car.prototype); // Output: {constructor: ƒ Car()}
Створення нового об'єкта за допомогою new:
Коли ви викликаєте функцію-конструктор за допомогою new:


    const myCar = new Car('Toyota', 'Camry');
Відбувається наступне:

Створюється новий порожній об'єкт.
this у функції-конструкторі прив'язується до цього нового об'єкта.
Найважливіше: Властивість [[Prototype]] нового об'єкта (myCar) встановлюється на об'єкт, на який посилається Car.prototype. Тобто, Object.getPrototypeOf(myCar) буде посилатися на Car.prototype.
Функція-конструктор виконується, додаючи властивості (наприклад, make та model) до нового об'єкта.
Новий об'єкт повертається.

    console.log(myCar.make); // Toyota
    console.log(Object.getPrototypeOf(myCar) === Car.prototype); // true
Переваги використання прототипів:
Спільне використання методів (Inheritance/Shared Behavior):
Якщо у вас є методи, які повинні бути доступні для всіх екземплярів об'єкта, створеного за допомогою певного конструктора, краще розміщувати ці методи на прототипі конструктора, а не безпосередньо в самому конструкторі.

Приклад без прототипу (неефективно):

    function Animal(name) {
      this.name = name;
      this.speak = function() { // Метод створюється для КОЖНОГО нового екземпляра
        console.log(`${this.name} makes a sound.`);
      };
    }
    const dog = new Animal('Dog');
    const cat = new Animal('Cat');
    console.log(dog.speak === cat.speak); // false (різні функції в пам'яті)
У цьому випадку, якщо ви створите 1000 об'єктів Animal, у вас буде 1000 окремих функцій speak у пам'яті, що є неефективним.

Приклад з прототипом (ефективно):

    function Animal(name) {
      this.name = name;
    }

// Додаємо метод до прототипу
    Animal.prototype.speak = function() {
      console.log(`${this.name} makes a sound.`);
    };

    const dog = new Animal('Dog');
    const cat = new Animal('Cat');

    dog.speak(); // Dog makes a sound.
    cat.speak(); // Cat makes a sound.

    console.log(dog.speak === cat.speak); // true (посилаються на ОДНУ функцію на прототипі)
Тут метод speak існує лише один раз на Animal.prototype. Коли dog.speak() або cat.speak() викликається, JavaScript спочатку шукає speak на об'єкті dog (або cat). Не знайшовши його, він піднімається по ланцюжку прототипів до Animal.prototype, де знаходить і виконує метод speak. Це значно економить пам'ять і є основою для "успадкування" поведінки.

Ланцюжок прототипів (Prototype Chain):
Об'єкти можуть мати прототипи, які, своєю чергою, також мають прототипи, утворюючи ланцюжок. Пошук властивостей та методів відбувається вгору по цьому ланцюжку, доки властивість не буде знайдена або ланцюжок не закінчиться (досягнувши null, що є прототипом Object.prototype).

Наприклад, myCar -> Car.prototype -> Object.prototype -> null.
Методи, як toString() або hasOwnProperty(), які доступні для будь-якого об'єкта в JavaScript, знаходяться на Object.prototype.

Узагальнення:
Функція-конструктор: Використовується для створення екземплярів об'єктів.
Властивість prototype (функції-конструктора): Це об'єкт, який служить прототипом для всіх об'єктів, створених цим конструктором. Методи та властивості, які ви хочете, щоб були спільними для всіх екземплярів, додаються сюди.
[[Prototype]] (екземпляра об'єкта): Це внутрішнє посилання від екземпляра об'єкта на об'єкт prototype його конструктора.
Розуміння прототипів є ключовим для розуміння об'єктно-орієнтованого програмування в JavaScript до появи класів ES6, і навіть з класами, концепція прототипів залишається в основі їхньої роботи. Класи ES6 – це по суті синтаксичний цукор (syntactic sugar) над прототипним успадкуванням.


Що таке Прототип?
Уявіть, що ви не просто надрукували книги за шаблоном. Уявіть, що ви також створили додатковий "лист-інструкцію" або "довідник", який є спільним для всіх книг, надрукованих за цим шаблоном.

Цей "лист-інструкція" і є Прототип (Function.prototype).
Ось як це працює:

Функція-конструктор (Шаблон): Це ваш оригінальний макет книги. Ви його створюєте, щоб друкувати багато примірників.


    function Book(title, author) {
      this.title = title;
      this.author = author;
    }
Прототип (Спільний Довідник): Коли ви створюєте Book як функцію-конструктор, JavaScript автоматично створює для неї прихований "довідник", який називається Book.prototype.

Він один на всіх! Це не окремий довідник для кожної книги, а єдиний, спільний для всіх книг, створених за цим шаблоном.
Спочатку цей довідник порожній (містить лише посилання на сам конструктор).
Додаємо методи до Прототипу (Інструкції в Довіднику):
Якщо ви хочете, щоб усі ваші книги мали, наприклад, функцію "Показати Зміст", ви не будете друкувати цю функцію на кожній сторінці кожної книги. Ви просто напишете її один раз у цьому "довіднику" (на прототипі).


    Book.prototype.showContents = function() {
      console.log(`Contents of "${this.title}" by ${this.author}.`);
    };
Тепер showContents існує лише один раз у пам'яті, але доступна для всіх книг.

Екземпляр об'єкта (Надрукований Примірник Книги): Коли ви створюєте нову книгу за шаблоном:


    const myBook = new Book('The Great Story', 'Author X');
Ваша книга myBook отримує свої власні унікальні дані (назву, автора).
Але вона також отримує "приховане посилання" (те саме [[Prototype]] або __proto__) на цей спільний "довідник" (Book.prototype).
Як це працює (Пошук Інструкцій):
Коли ви намагаєтеся викликати метод myBook.showContents():

JavaScript спочатку шукає "showContents" на самій книзі myBook.
Він її там не знаходить.
Тоді він йде за "прихованим посиланням" до "довідника" (Book.prototype).
Ага! У довіднику є "showContents"! JavaScript бере цю інструкцію і виконує її.
Головна ідея: Економія та Успадкування
Економія пам'яті: Замість того, щоб кожна надрукована книга мала свою власну копію методу showContents, він зберігається лише один раз у спільному "довіднику" (прототипі).
Успадкування: Кожна нова книга "успадковує" доступ до всіх інструкцій, які написані в цьому спільному "довіднику". Це дозволяє створювати багато об'єктів, які мають спільну поведінку.
Отже, прототип — це спільний об'єкт, який служить "довідником" або "архівною полицею" для всіх екземплярів, створених за певним шаблоном (функцією-конструктором), і містить методи та властивості, які ці екземпляри можуть використовувати, не дублюючи їх у пам'яті.


Гарне запитання! Це ключовий момент для розуміння того, як JavaScript працює "під капотом".

Навіть якщо вам не потрібно додавати свої власні методи чи властивості до прототипу, він все одно існує і має свою роль.

Давайте повернемося до нашої аналогії з книгами, але цього разу зосередимося на тому, що відбувається за замовчуванням.

Якщо "довідник" (Прототип) пустий? Його роль.
Уявіть, що ви створили шаблон для книги, але не додали до його "довідника" (прототипу) жодних своїх інструкцій (методів).

Автоматичний "Довідник":
Коли ви створюєте функцію-конструктор Book, JavaScript автоматично створює для неї цей "довідник" (Book.prototype). Навіть якщо ви нічого туди не додаєте, він не є зовсім порожнім. За замовчуванням, він містить одну єдину інструкцію: constructor.

Book.prototype = { constructor: Book };
Ця constructor властивість просто вказує назад на функцію Book (ваш шаблон). Це корисно, якщо ви хочете дізнатися, за яким шаблоном була створена та чи інша книга.
"Приховане посилання" залишається:
Кожен примірник книги (myBook = new Book(...)) все одно отримує "приховане посилання" ([[Prototype]] або __proto__) на цей Book.prototype. Навіть якщо ви не збираєтеся його використовувати для власних методів.

Ланцюжок Прототипів Все Одно Працює:
І ось тут найважливіша частина: Book.prototype сам по собі не є "кінцем ланцюжка". Він, своєю чергою, також має "приховане посилання" на свій прототип. А його прототипом є Object.prototype.

Book.prototype -> Object.prototype -> null
Що таке Object.prototype?
Це найбазовіший, універсальний "довідник" JavaScript, який є прототипом для всіх об'єктів. Він містить дуже поширені, вбудовані методи, які ми використовуємо щодня, навіть не замислюючись:

toString(): метод, який перетворює об'єкт на рядок (наприклад, коли ви робите console.log(myBook)).
hasOwnProperty(): метод, який перевіряє, чи має об'єкт свою власну властивість (а не успадковану).
valueOf(): повертає примітивне значення об'єкта.
Роль пустого прототипу:

Навіть якщо Book.prototype виглядає "пустим" для вас, він слугує проміжним ланцюжком до Object.prototype. Це означає, що ваші екземпляри myBook можуть використовувати всі ці базові методи toString(), hasOwnProperty() тощо, без того, щоб ці методи були скопійовані на кожен примірник книги.

Коли ви викликаєте myBook.toString():

JavaScript шукає toString на myBook (немає).
Йде за посиланням на Book.prototype (немає, бо ви нічого туди не додали).
Йде за посиланням з Book.prototype на Object.prototype (Ось він!).
Виконує Object.prototype.toString().
Отже, навіть "пустий" прототип:

Забезпечує посилання на функцію-конструктор (constructor).
Слугує "мостиком" у ланцюжку прототипів, дозволяючи вашим екземплярам об'єктів "успадковувати" базові, вбудовані методи від Object.prototype (і потенційно від інших прототипів вище в ланцюжку, якщо ви будуєте складнішу ієрархію).
Він не "висить пустим" без сенсу; він є невід'ємною частиною архітектури успадкування в JavaScript.
*/

function User1 (name, surname, age, isMale, email, isSubscribed) {
    this.firstName = name;
    this.lastName = surname;
    this.age = age;
    this.isMale = isMale;
    this.email = email;
    this.isSubscribed = isSubscribed;
}
// задали прототипу метод getFullName
// всі методи що в протопипі функції-констурктора - вони для екземплрів. Тобто кожен екземляр міститиме в собі доступ до методу через ланцюжок прототипів
User1.prototype.getFullName = function() {
    return this.firstName + ' ' + this.lastName;
};
// задали що у фунцкії конструктора User в прототипі буде об'єкт cвій метод getFullName

// всі методи глобальних об'єктів (нема слова prototype) - для самої функції-конструктора а нен для екземплярів
User1.isUser = function (obj) {
    return obj instanceof User1;  // перевіряє чи є User в ланцюжку прототипів user1, якщо є значить user1 вважається екземпляром User
};

// класичний спосіб задати прототип
// const userProto = new User(); // userProto is instance of User
// User.prototype = userProto;  // userProto буде прототипом User

// За рахунок цього

const user1 = new User1 (  // через new ми свторюємо instance тобто об'єкт типу User
    'Jack',
    'Wilsher', 
    23,
    true,
    'test@gmail.com',
    true
);

// коли виведемо в консоль то в прототипах побачимо constructor: f User1 (parameters) + метод

// тепер якщо в консолі ввести user1 то отримаємо об'єкт, який є прототипом User і має в собі свій метод getFullName.
// при цьому сам конструктор немає методу getFullName, лише його прототип і екземпляр об'єкту user1


// ------------------------------------------------------------------------------------------------------------------------------

// Якщо ми на MDN відкриєм наприклад Array і його методи то побачим два типи методів:
// 1. Array.prototype.join() - Це метод прототипу, що означає, що він доступний для всіх екземплярів (об'єктів) масиву, а не для самої функції-конструктора 
    // це чудовий приклад методу, який успадковується всіма масивами через їхній ланцюжок прототипів, забезпечуючи спільну поведінку без дублювання коду в кожному окремому масиві.

// 2. Array.isArray() - це статичні методи, вони діють на самому об'єкті функції-конструктора. Він не працює на окремих екземплярах масивів.
    // User.isUser = function(obj) {
    //     return obj instanceof User;
    // }


// ----------------------------------------------------------------------------------------------------------------------------------------------------




// В інших мовах програмування методи не записуються на прототипах, вони записуються на класах
//  В JS немає класів як таких (як в інших мовах). При цьому є поняття класів для імітації (хоча по суті це лише оболонка під якою ми так само працюємо з функціями-конструкторами, яких немає в іних мовах)
// В JS  класи це - синтаксичний цукор на вбудованими в JS функціями-конструкторами та прототипами

// Отже класовий підхід JS


//ключове слово + Назва з Вел.літери нового типу даних
// class User {
//     //ключове слово методу для створення обєктів цього класу + parameters
//     constructor (name, surname, age, isMale, email, isSubscribed) {
//         //тіло конструктора
//         // ! якщо імя властивості починається з _firstName значить до нього не можна звертатись прото так (приватне поле тіпа)
//             this.firstName = name;
//             this.lastName = surname;
//             this.age = age;
//             this.isMale = isMale;
//             this.email = email;
//             this.isSubscribed = isSubscribed;
//     }
//     // методи прототипів - пишемо в клас, але не в конструктор. Таким чином метод потрапляє в прототип а властивості потрабляють в сам обєкт
//     getFullName () {
//         return `${this.firstName} ${this.lastName}`;
//     }
//     // статичні методи пишем через ключов слово static + назва методу + обєкт + тіло методу
//     // через ключове слолво воно не потрапить до екземплярів, тобто застосується лише самого класу (функції конструктора під капотом)
//     // в static немає this
//     static isUser (obj) {
//         return obj instanceof User;
//     }
// }

// const user2 = new User(
//     'Jack',
//     'Wilsher', 
//     23,
//     true,
//     'test@gmail.com',
//     true
// )

// console.log(user2.getFullName());
// коли виведемо в консоль то в прототипах побачимо constructor: class User





//########################################################################################################################################################

                // Сеттери та Геттери (Get and Set Methods)
                
// Вище ми розібрали методи прототипів та методи статичні.
// Але є ще специфічні методи такі як : Set та Get


// У контексті класів JavaScript, get (геттер) та set (сеттер) — це особливі методи, які дозволяють вам контролювати доступ до властивостей об'єкта.

// get (геттер):
// Використовується для читання значення властивості.
// Дозволяє виконувати додаткову логіку (наприклад, обчислення, форматування) щоразу, коли до властивості звертаються.
// Викликається як звичайна властивість, без дужок: obj.property.

// set (сеттер):
// Використовується для запису значення у властивість.
// Дозволяє виконувати валідацію даних або інші дії (наприклад, оновлення інтерфейсу) щоразу, коли властивості присвоюється нове значення.
// Викликається при присвоєнні значення: obj.property = value.

// Коротко: Вони надають вам контроль над тим, як властивості об'єкта читаються та змінюються, дозволяючи інкапсулювати логіку доступу.



// На попередньому прикладі, наприклад нам потрібно задати ageб але попередньо він повинен пройти перевірку (наприклад щоб користувач не вказав вік відємне число, або літери)
// для цього є спеціальний вид методу сеттер set

class User {
    constructor (name, surname, age, isMale, email, isSubscribed) {
            this.firstName = name;
            this.lastName = surname;
            this.age = age;
            this.isMale = isMale;
            this.email = email;
            this.isSubscribed = isSubscribed;
    }
    //це особливий тип методів, до нього треба звертатись інакше user2.age=20 - як до властивості (де user2 це обєкт, age - це назва методу set, = це і є сам set(виконання сету,присвоєння значення), 20 - значення)
    // 
    set age(value) {
        //задати якусь перевірку, наприклад чи дійсно я маю право записати якесь значення або чи це число, якщо да то хай це значення присвоїться

        if(typeof value !== 'number'){
            throw new TypeError('Age must be a number')
        }
        if(value < 0 || value > 150) {
            throw new RangeError ('Age must be between 0 and 150')
        }
        this.userAge = value;
    }
    // щоб зчитати, отримати інформацію з екземпляра, наприклад щоб посмістити її в змінну чи використати для чогось використ метод Get
    // що нього звераємось так само як і до set, як до властивості user2.age;
    // також називати їх треба однаково, якщо задаємо через назву age то і зчитувати маємо через age
    get age() {
        return this.userAge;
    }
    // до інших методів звертамось отак: user2.getFullName() - як до функції
    getFullName () {
        return `${this.firstName} ${this.lastName}`;
    }
    static isUser (obj) {
        return obj instanceof User;
    }
}

let user2;

// оскільки ми в сеттері робим перевірку, і задаємо помилки то не забуваємо відхоплювати ці помилки через try-catch щоб не ламати подальний скрипт
// також краще const user2 = new user... теж перемістити в try бо помилка відхоплюється через сеттер, але якщо ми напряму через екземпляр залізем і поміняєм значення властивості, то властивості спокійно присвоїться будь яке значенння обійшовши перевірку в сет
// але ми втратим доступ до user2 після переміщення через область видимості, тому в глобальній області видимості визначим змінну, а в try задамо значення!!!
//Це дозволить нам добиратись напряму до властивості екземпляра
try {
    
     user2 = new User(
        'Jack',
        'Wilsher', 
        23,
        true,
        'test@gmail.com',
        true
    )

    console.log(user2.getFullName());
    console.log(user2.age);

    user2.age = 20
} catch (err) {
    console.log(err);
}